# Lesson 2.4: Signal-based State Management Patterns

## The Pattern: Signal Store Service

Extract component state into an injectable service using signals:

```
Component state (signal in component)
    ↓ extract to
Injectable service (signal in service)
    ↓ expose via
Read-only signals (public) + mutation methods (public)
    ↓ private internals
Writable signals (private)
```

---

## Key Principles

1. **Private writable signals** — only the store can mutate state
2. **Public read-only signals** — consumers read via `asReadonly()`
3. **Public methods for mutations** — named actions that describe intent
4. **Computed for derived state** — lives in the store, shared across all consumers

---

## Signal Store Template

```typescript
import { Injectable, computed, signal } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class MyStore {
  // Private writable state
  private readonly _items = signal<Item[]>([]);

  // Public read-only signals
  readonly items = this._items.asReadonly();

  // Derived state
  readonly count = computed(() => this._items().length);

  // Named mutations
  add(item: Item): void {
    this._items.update(items => [...items, item]);
  }

  remove(id: number): void {
    this._items.update(items => items.filter(i => i.id !== id));
  }
}
```

### Using in Components

```typescript
@Component({ ... })
export class MyComponent {
  private readonly store = inject(MyStore);

  readonly items = this.store.items;     // read-only signal
  readonly count = this.store.count;     // computed from store

  add(item: Item) {
    this.store.add(item);                // mutate through store
  }
}
```

---

## `asReadonly()` — Encapsulation

```typescript
private readonly _tasks = signal<Task[]>([]);

// Public: consumers can read but not call .set() or .update()
readonly tasks = this._tasks.asReadonly();
```

This prevents consumers from bypassing store methods to mutate state directly.

---

## `providedIn` Scope

```typescript
@Injectable({ providedIn: 'root' })    // Singleton — shared everywhere (most common)
@Injectable()                           // Must be provided explicitly in component/route
```

For MF shared state, use `providedIn: 'root'` so all micro-apps share the same instance.

### Component-scoped stores
```typescript
@Component({
  providers: [TaskStore],  // New instance per component
})
```

Useful when you want isolated state per feature/route.

---

## Exercise: Extract TaskStore

### task.store.ts
```typescript
import { Injectable, computed, signal } from '@angular/core';
import { Task } from './task';

@Injectable({ providedIn: 'root' })
export class TaskStore {
  private readonly _tasks = signal<Task[]>([
    { id: 1, title: 'Learn signals', done: true },
    { id: 2, title: 'Build with NX', done: false },
    { id: 3, title: 'Setup microfrontends', done: false },
  ]);

  readonly tasks = this._tasks.asReadonly();

  readonly stats = computed(() => {
    const all = this._tasks();
    const done = all.filter(t => t.done).length;
    return { total: all.length, done, remaining: all.length - done };
  });

  addTask(title: string): void {
    if (!title.trim()) return;
    this._tasks.update(tasks => [...tasks, {
      id: Date.now(), title, done: false,
    }]);
  }

  toggleTask(id: number): void {
    this._tasks.update(tasks =>
      tasks.map(t => t.id === id ? { ...t, done: !t.done } : t)
    );
  }

  removeTask(id: number): void {
    this._tasks.update(tasks => tasks.filter(t => t.id !== id));
  }
}
```

### Updated TaskTracker Component
```typescript
@Component({
  selector: 'app-task-tracker',
  imports: [TaskItem, TaskFilter],
  templateUrl: './task-tracker.html',
  styleUrl: './task-tracker.css',
})
export class TaskTracker {
  private readonly store = inject(TaskStore);

  readonly tasks = this.store.tasks;
  readonly stats = this.store.stats;
  readonly filter = signal<'all' | 'active' | 'completed'>('all');

  readonly filteredTasks = computed(() => {
    const tasks = this.tasks();
    switch (this.filter()) {
      case 'active': return tasks.filter(t => !t.done);
      case 'completed': return tasks.filter(t => t.done);
      default: return tasks;
    }
  });

  addTask(title: string): void { this.store.addTask(title); }
  toggleTask(id: number): void { this.store.toggleTask(id); }
  removeTask(id: number): void { this.store.removeTask(id); }
}
```

Template stays exactly the same — no HTML changes needed.

---

## When Signal Stores Are Enough vs NgRx Signal Store

### Signal stores (no library) — use when:
- Shared state across multiple components/routes
- Straightforward state logic (CRUD, toggles, filters)
- No need for dev tools or time-travel debugging
- Small-to-medium teams

### NgRx Signal Store — consider when:
- Need middleware (logging, dev tools)
- Complex async with loading/error states
- Very large teams needing strict action patterns
- Want `withEntities()`, `withMethods()`, `withComputed()` helpers

For most apps, signal stores are enough. Migration to NgRx Signal Store is straightforward since the concepts are nearly identical.

---

## Key Takeaways

1. **Signal store pattern** = private writable signals + public readonly + named mutation methods
2. **`asReadonly()`** prevents consumers from bypassing store methods
3. **Computed state in the store** is shared across all consumers — calculate once, use everywhere
4. **`providedIn: 'root'`** = singleton store; component-level `providers` = scoped instance
5. Component becomes thin — just `inject(Store)`, expose what the template needs, delegate mutations
6. Template stays unchanged when extracting to a store — that's the sign of good separation
7. For most Angular apps, signal stores replace the need for NgRx/Akita/etc.
8. This pattern maps directly to MF shared state later (Module 8)
