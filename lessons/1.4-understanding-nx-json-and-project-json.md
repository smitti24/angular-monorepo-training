# Lesson 1.4: Understanding nx.json & project.json

## Theory: The Config Inheritance Model

NX config flows from workspace-level defaults down to project-level specifics:

```
nx.json (workspace defaults)
   ↓ merged into
project.json (per-project config)
   ↓ resolved by
nx show project <name> (final resolved config)
```

---

## nx.json — Deep Dive

### `defaultBase`
```json
"defaultBase": "master"
```
The git branch NX compares against for `nx affected` commands. Determines "what changed since the base branch?" Change to `"main"` if that's your default branch.

### `namedInputs` — The Caching Brain
```json
"namedInputs": {
  "default": ["{projectRoot}/**/*", "sharedGlobals"],
  "production": [
    "default",
    "!{projectRoot}/.eslintrc.json",
    "!{projectRoot}/eslint.config.mjs"
  ],
  "sharedGlobals": []
}
```

Named inputs define **what files NX watches** to decide if a cache is valid:

| Input | What it includes | Used by |
|-------|-----------------|---------|
| `default` | All files in the project + sharedGlobals | `test`, `lint` |
| `production` | Everything in `default` MINUS lint config | `build` |
| `sharedGlobals` | Workspace-wide files that affect all projects | Everything |

- The `!` prefix means **exclude**
- `production` excludes eslint config because changing lint rules shouldn't invalidate build cache
- `{projectRoot}` resolves to the project's directory (e.g., `apps/shell`)
- `{workspaceRoot}` resolves to the repo root

**Real-world addition — shared env files:**
```json
"sharedGlobals": ["{workspaceRoot}/.env"]
```

### `targetDefaults` — Workspace-Wide Target Config
```json
"targetDefaults": {
  "@angular/build:application": {
    "cache": true,
    "dependsOn": ["^build"],
    "inputs": ["production", "^production"]
  },
  "@nx/eslint:lint": {
    "cache": true,
    "inputs": ["default", "{workspaceRoot}/eslint.config.mjs"]
  },
  "@angular/build:unit-test": {
    "cache": true,
    "inputs": ["default", "^production"]
  }
}
```

These apply to **every project** using that executor. Key concepts:

- **`cache: true`** — enables computation caching for this target
- **`dependsOn: ["^build"]`** — build dependencies first (`^` = upstream projects)
- **`inputs`** — what NX hashes to determine cache validity
  - `"production"` = this project's production files
  - `"^production"` = dependencies' production files (the `^` prefix)

**Why test uses `"default"` but build uses `"production"`:**
- Tests should re-run when lint config changes (they might import test utilities)
- Builds don't care about lint config — only production source matters

### `plugins` — Auto-Inferred Targets
```json
"plugins": [
  { "plugin": "@nx/playwright/plugin", "options": { "targetName": "e2e" } },
  { "plugin": "@nx/eslint/plugin", "options": { "targetName": "lint" } }
]
```

Plugins can auto-detect targets from config files:
- Playwright plugin sees `playwright.config.ts` → registers `e2e` target
- ESLint plugin sees `eslint.config.mjs` → registers `lint` target

These targets don't need to be defined in `project.json` — they're inferred.

### `generators` — Saved Defaults
```json
"generators": {
  "@nx/angular:application": {
    "e2eTestRunner": "playwright",
    "linter": "eslint",
    "style": "css",
    "unitTestRunner": "vitest-angular"
  }
}
```

Saved from initial app generation. Future `nx generate` calls use these defaults automatically.

---

## project.json — Deep Dive

### Target Anatomy
```json
"targetName": {
  "executor": "@scope/plugin:executor-name",
  "options": { ... },            // default options (always applied)
  "configurations": {            // named override sets
    "production": { ... },
    "development": { ... }
  },
  "defaultConfiguration": "production"
}
```

### Configuration Merge Model
```
options (base) + configurations.<name> (overrides) = final config
```

- `nx build shell` → uses `defaultConfiguration: "production"` → options + production overrides
- `nx build shell -c development` → options + development overrides
- `nx serve shell` → uses `defaultConfiguration: "development"` → optimized for dev

### The `serve` → `build` Connection
```json
"serve": {
  "configurations": {
    "development": {
      "buildTarget": "shell:build:development"
    }
  }
}
```

The dev server references the build target's development configuration using `project:target:configuration` format. It doesn't duplicate build config — it delegates.

### `outputs` — Cache Artifact Location
```json
"outputs": ["{options.outputPath}"]
```
Tells NX where build artifacts go (`dist/apps/shell`). NX stores this so it can restore output from cache without rebuilding.

### `tags` — Boundary Enforcement
```json
"tags": []
```
Empty now. In Module 3, we'll add tags like `"type:app"`, `"scope:shell"` to enforce which libraries can import from which.

---

## tsconfig.base.json — The Library Bridge

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {}
  }
}
```

The `paths` object is the key to cross-project imports. When you create a library (Module 3), NX auto-adds:
```json
"paths": {
  "@nx-mf-training/shared-ui": ["libs/shared-ui/src/index.ts"]
}
```

This enables clean imports from any app/lib:
```typescript
import { ButtonComponent } from '@nx-mf-training/shared-ui';
```

No relative paths across project boundaries.

### Per-Project tsconfig Inheritance
```
tsconfig.base.json (workspace)
   ↓ extended by
apps/shell/tsconfig.json (project-level overrides: strict mode, Angular compiler options)
   ↓ referenced by
tsconfig.app.json (build)     tsconfig.spec.json (tests)
```

---

## Hands-On

### 1. See Config Resolution in Action
```bash
npx nx show project shell       # Full resolved config
npx nx show project shell-e2e   # Notice the inferred 'e2e' target
```

Compare `shell-e2e` output to its `project.json` — the `e2e` target was inferred by the Playwright plugin.

### 2. Verify defaultBase
```bash
git branch    # Check if your default branch is 'main' or 'master'
```
If it's `main`, update `defaultBase` in `nx.json` to `"main"`.

---

## Key Takeaways

1. **nx.json** = workspace defaults; **project.json** = per-project overrides; `nx show project` = resolved result
2. **namedInputs** control cache invalidation — `production` excludes lint/test config for tighter caching
3. **`^` prefix** in inputs/dependsOn means "upstream dependencies" — critical for correct cache behavior
4. **Plugins auto-infer targets** from config files (Playwright, ESLint) — less boilerplate in project.json
5. **Configuration merge**: `options` (base) + `configurations.<name>` (overrides) = final config
6. **tsconfig.base.json `paths`** is how NX enables clean cross-project imports — auto-populated by generators
7. Use `nx show project <name>` to debug config issues — it shows the final resolved config
