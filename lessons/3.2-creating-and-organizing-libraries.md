# Lesson 3.2: Creating & Organizing Libraries

## Theory: Moving Code into Libraries

The refactor pattern:
1. **Apps are thin** — they compose libraries, nothing more
2. **Libraries own the code** — business logic, components, services all live in libs
3. **Barrel files (`index.ts`)** control the public API — only export what consumers need
4. **Workspace path aliases** (`@nx-mf-training/shared-ui`) replace relative imports across project boundaries

---

## Refactor Plan

| Code | From (shell app) | To (library) |
|------|-------------------|---------------|
| `Task` interface | `task.ts` | `libs/shared/util/` |
| `TaskStore` | `store/task.store.ts` | `libs/tasks/data-access/` |
| `TaskItem`, `TaskFilter` | `components/` | `libs/shared/ui/` |
| `TaskTracker` | `task-tracker.ts` | `libs/tasks/feature/` |

---

## Step-by-Step

### 1. Move `Task` interface → `libs/shared/util/`

- Copy to `libs/shared/util/src/lib/task.ts`
- Delete placeholder files in `libs/shared/util/src/lib/util/`
- Export from `libs/shared/util/src/index.ts`:
```typescript
export { Task } from './lib/task';
```

### 2. Move `TaskStore` → `libs/tasks/data-access/`

- Copy to `libs/tasks/data-access/src/lib/task.store.ts`
- Update import:
```typescript
import { Task } from '@nx-mf-training/shared-util';
```
- Export from `libs/tasks/data-access/src/index.ts`:
```typescript
export { TaskStore } from './lib/task.store';
```

### 3. Move `TaskItem` & `TaskFilter` → `libs/shared/ui/`

- Copy folders to `libs/shared/ui/src/lib/task-item/` and `libs/shared/ui/src/lib/task-filter/`
- Update imports to use workspace paths:
```typescript
import { Task } from '@nx-mf-training/shared-util';
```
- Export from `libs/shared/ui/src/index.ts`:
```typescript
export { TaskItem } from './lib/task-item/task-item';
export { TaskFilter } from './lib/task-filter/task-filter';
```

### 4. Move `TaskTracker` → `libs/tasks/feature/`

- Copy `task-tracker.ts`, `.html`, `.css` to `libs/tasks/feature/src/lib/`
- Update imports:
```typescript
import { TaskItem, TaskFilter } from '@nx-mf-training/shared-ui';
import { TaskStore } from '@nx-mf-training/tasks-data-access';
```
- Export from `libs/tasks/feature/src/index.ts`:
```typescript
export { TaskTracker } from './lib/task-tracker';
```

### 5. Update Shell App

```typescript
// app.ts
import { TaskTracker } from '@nx-mf-training/tasks-feature';

@Component({
  imports: [RouterModule, TaskTracker],
  ...
})
export class App {}
```

Delete `apps/shell/src/app/task-tracker/` folder entirely.

### 6. Verify

```bash
npx nx serve shell    # App still works
npx nx graph          # Dependency graph shows connections
```

Expected graph:
```
shell → tasks-feature → tasks-data-access → shared-util
                       → shared-ui → shared-util
```

---

## Barrel Files (`index.ts`) — The Public API

```typescript
// libs/shared/ui/src/index.ts
export { TaskItem } from './lib/task-item/task-item';
export { TaskFilter } from './lib/task-filter/task-filter';
// Internal helpers — NOT exported = private to this library
```

Only what's in `index.ts` is importable by other projects. Everything else is internal. This is your library's **public API contract**.

---

## Key Takeaways

1. **Move code, update imports, export from barrel** — that's the entire refactor pattern
2. **Shell becomes thin** — just imports the feature library and renders it
3. **Workspace paths** (`@nx-mf-training/...`) replace relative imports across project boundaries
4. **Barrel files** (`index.ts`) are the public API — unexported code is private to the library
5. **`nx graph`** lights up with connections after the refactor — NX now understands your architecture
6. **Delete old code** from the app after confirming the library version works
7. This structure directly maps to microfrontends — features become remote app entry points
