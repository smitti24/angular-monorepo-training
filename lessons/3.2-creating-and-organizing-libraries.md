# Lesson 3.2: Creating & Organizing Libraries

## Theory: Moving Code into Libraries

The refactor pattern:
1. **Apps are thin** — they compose libraries, nothing more
2. **Libraries own the code** — business logic, components, services all live in libs
3. **Barrel files (`index.ts`)** control the public API — only export what consumers need
4. **Workspace path aliases** (`@nx-mf-training/...`) replace relative imports across project boundaries

### Domain-Driven Organization Rule

**If code knows about a domain concept, it belongs under that domain's folder — NOT in shared.**

- `shared/` = truly generic, reusable across ANY domain (buttons, pipes, loggers)
- `tasks/` = anything that knows about the `Task` type or task business logic

| Wrong | Right | Why |
|-------|-------|-----|
| `shared/ui/TaskItem` | `tasks/ui/TaskItem` | TaskItem knows about Task — it's domain-specific |
| `shared/util/Task` | `tasks/data-access/Task` | Task is a domain model, not a generic utility |

---

## Correct Library Architecture

```
libs/
├── tasks/                        ← Domain grouping folder
│   ├── feature/                  → TaskTracker (smart/container component)
│   ├── ui/                       → TaskItem, TaskFilter (presentational components)
│   └── data-access/              → TaskStore + Task interface (state + models)
└── shared/                       ← Cross-domain grouping folder
    ├── ui/                       → (empty — future generic components: buttons, modals)
    └── util/                     → (empty — future generic utilities: pipes, helpers)
```

---

## Step-by-Step

### 1. Move `Task` interface → `libs/tasks/data-access/`

The Task interface is a domain model — it belongs with the data layer.

- Create `libs/tasks/data-access/src/lib/data-access/task.ts`
- Export from barrel using `export type` (required with `isolatedModules`):
```typescript
// libs/tasks/data-access/src/index.ts
export { TaskStore } from './lib/data-access/task.store';
export type { Task } from './lib/data-access/task';
```
- TaskStore uses relative import (same library):
```typescript
import { Task } from './task';
```

### 2. Move `TaskStore` → `libs/tasks/data-access/`

- Create `libs/tasks/data-access/src/lib/data-access/task.store.ts`
- Export from barrel:
```typescript
export { TaskStore } from './lib/data-access/task.store';
```

### 3. Generate `tasks/ui` library

```bash
# vitest-angular requires buildable — bypass with --unitTestRunner=none
npx nx generate @nx/angular:library --name=tasks-ui --directory=libs/tasks/ui --buildable=false --prefix=ui --skipTests --unitTestRunner=none
```

Then manually add test target to project.json (inside `targets`):
```json
"test": {
  "executor": "@nx/angular:unit-test",
  "options": {}
}
```

**Note:** NX requires unique project names. If `ui` already exists (shared/ui), use `tasks-ui` as the name.

### 4. Move `TaskItem` & `TaskFilter` → `libs/tasks/ui/`

- Move to `libs/tasks/ui/src/lib/task-item/` and `libs/tasks/ui/src/lib/task-filter/`
- TaskItem imports Task from the workspace alias (cross-library):
```typescript
import { Task } from '@nx-mf-training/data-access';
```
- Export from barrel:
```typescript
// libs/tasks/ui/src/index.ts
export { TaskItem } from './lib/task-item/task-item';
export { TaskFilter } from './lib/task-filter/task-filter';
```

### 5. Move `TaskTracker` → `libs/tasks/feature/`

- Create in `libs/tasks/feature/src/lib/feature/task-tracker/`
- Update imports to use workspace aliases:
```typescript
import { TaskStore } from '@nx-mf-training/data-access';
import { TaskItem, TaskFilter } from '@nx-mf-training/tasks/ui';
```
- Export from barrel:
```typescript
export { TaskTracker } from './lib/feature/task-tracker/task-tracker';
```

### 6. Update Shell App

```typescript
// apps/shell/src/app/app.ts
import { TaskTracker } from '@nx-mf-training/feature';
```

Delete all task-tracker code from `apps/shell/src/app/` — the app is now thin.

### 7. Add tsconfig path alias

```json
// tsconfig.base.json
"paths": {
  "@nx-mf-training/tasks/ui": ["libs/tasks/ui/src/index.ts"],
  "@nx-mf-training/data-access": ["libs/tasks/data-access/src/index.ts"],
  "@nx-mf-training/feature": ["libs/tasks/feature/src/index.ts"]
}
```

### 8. Verify

```bash
npx nx serve shell    # App still works
npx nx graph          # Dependency graph shows connections
```

Expected graph:
```
shell → feature → tasks-ui → data-access
                → data-access
```

`shared/ui` and `shared/util` appear as isolated nodes (no connections).

---

## Import Rules

| Import type | When | Example |
|-------------|------|---------|
| **Relative** (`./task`) | Same library | TaskStore importing Task |
| **Workspace alias** (`@nx-mf-training/...`) | Cross-library | TaskItem importing Task from data-access |
| **Never** | Deep imports into another library | `@nx-mf-training/data-access/src/lib/task` |

---

## Barrel Files (`index.ts`) — The Public API

```typescript
// libs/tasks/data-access/src/index.ts
export { TaskStore } from './lib/data-access/task.store';
export type { Task } from './lib/data-access/task';
// Internal helpers — NOT exported = private to this library
```

Only what's in `index.ts` is importable by other projects. Everything else is internal.

---

## NX Generator Gotchas (NX 22)

1. **vitest-angular requires buildable** — use `--unitTestRunner=none` then add test target manually
2. **Project name collisions** — NX requires unique names across workspace. Use scoped names (`tasks-ui`, `shared-ui`)
3. **Buildable libraries + esbuild** — causes NG1010 errors. Use non-buildable for dev (compiled inline with app)
4. **`export type` required** — with `isolatedModules: true`, type-only re-exports need `export type { ... }`

---

## Key Takeaways

1. **Domain-driven organization** — if it knows about `Task`, it goes under `tasks/`, not `shared/`
2. **Shell becomes thin** — just imports the feature library and renders it
3. **Barrel files** are your library's public API contract
4. **Relative imports** within a library, **workspace aliases** across libraries
5. **Non-buildable libraries** compile inline with the app — no separate build step needed
6. **`nx graph`** visualizes your architecture — use it to validate dependency flow
7. This structure maps directly to microfrontends — features become remote app entry points
