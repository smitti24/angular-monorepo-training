# Lesson 2.2: signal(), computed(), effect()

## API Reference

### signal() — Writable Reactive Value
```typescript
const name = signal('Andre');
name();                          // Read: 'Andre'
name.set('Smith');               // Replace value
name.update(v => v.toUpperCase()); // Derive from current
```

### computed() — Derived Read-Only Value
```typescript
const greeting = computed(() => `Hello, ${name()}`);
greeting(); // 'Hello, SMITH' — auto-updates when name changes
```

- **Lazy**: only recalculates when a dependency changes AND someone reads it
- **Cached**: returns same value if dependencies haven't changed
- **Must be pure**: no side effects, no writing to other signals
- **Auto-tracks**: reads signals inside the function to determine dependencies

### effect() — Side Effect
```typescript
effect(() => {
  console.log(`Name changed to: ${name()}`);
});
```

- **Re-runs** when any tracked signal changes
- **For side effects**: logging, localStorage, DOM manipulation, API calls
- **Auto-tracks**: any signal read inside becomes a dependency
- **Injection context required**: create in constructor, field initializer, or pass `Injector`

---

## Key Rules

1. `computed()` is lazy and cached — no recalc unless dependencies change AND someone reads
2. `computed()` must be pure — no side effects, no signal writes
3. `effect()` is for side effects — not for deriving state (use `computed` for that)
4. `effect()` auto-tracks — signals read inside become dependencies
5. `effect()` needs injection context — constructor or field initializer
6. **Immutable updates** — always create new references with `update()` for objects/arrays

---

## Signal Equality

Default: `===` comparison. Customize for special cases:

```typescript
const count = signal(0, { equal: (a, b) => Math.abs(a - b) < 5 });
```

---

## Exercise: Task Tracker Component

### Generate
```bash
npx nx generate @nx/angular:component --name=task-tracker --project=shell --path=apps/shell/src/app/task-tracker
```

### Interface
```typescript
interface Task {
  id: number;
  title: string;
  done: boolean;
}
```

### State (signals)
```typescript
tasks = signal<Task[]>([
  { id: 1, title: 'Learn signals', done: true },
  { id: 2, title: 'Build with NX', done: false },
  { id: 3, title: 'Setup microfrontends', done: false },
]);

filter = signal<'all' | 'active' | 'completed'>('all');
```

### Derived State (computed)
```typescript
filteredTasks = computed(() => {
  const current = this.tasks();
  switch (this.filter()) {
    case 'active': return current.filter(t => !t.done);
    case 'completed': return current.filter(t => t.done);
    default: return current;
  }
});

stats = computed(() => {
  const all = this.tasks();
  const done = all.filter(t => t.done).length;
  return { total: all.length, done, remaining: all.length - done };
});
```

### Side Effects (effect)
```typescript
constructor() {
  effect(() => {
    const s = this.stats();
    console.log(`Tasks: ${s.done}/${s.total} complete`);
  });
}
```

### Mutations
```typescript
addTask(title: string) {
  this.tasks.update(tasks => [...tasks, { id: Date.now(), title, done: false }]);
}

toggleTask(id: number) {
  this.tasks.update(tasks =>
    tasks.map(t => t.id === id ? { ...t, done: !t.done } : t)
  );
}

removeTask(id: number) {
  this.tasks.update(tasks => tasks.filter(t => t.id !== id));
}
```

### Template (new control flow)
```html
<h2>Task Tracker</h2>

<div>
  <input #newTask placeholder="New task..." />
  <button (click)="addTask(newTask.value); newTask.value = ''">Add</button>
</div>

<div>
  <button (click)="filter.set('all')">All ({{ stats().total }})</button>
  <button (click)="filter.set('active')">Active ({{ stats().remaining }})</button>
  <button (click)="filter.set('completed')">Done ({{ stats().done }})</button>
</div>

<ul>
  @for (task of filteredTasks(); track task.id) {
    <li>
      <input type="checkbox" [checked]="task.done" (change)="toggleTask(task.id)" />
      <span [style.text-decoration]="task.done ? 'line-through' : 'none'">{{ task.title }}</span>
      <button (click)="removeTask(task.id)">x</button>
    </li>
  } @empty {
    <li>No tasks found</li>
  }
</ul>
```

### Wire Up
In `app.html`:
```html
<app-task-tracker />
<router-outlet />
```

In `app.ts`:
```typescript
imports: [TaskTracker, RouterModule],
```

---

## What to Observe

1. **Console**: `effect()` logs on every toggle/add/remove
2. **Filter changes**: `filteredTasks` recomputes, but `stats` doesn't (different dependencies)
3. **Computed tracking**: each `computed()` only depends on the signals read inside it

---

## Key Takeaways

1. **`signal()`** = mutable state container, read by calling, write with `set()`/`update()`
2. **`computed()`** = derived state, lazy, cached, auto-tracks, must be pure
3. **`effect()`** = side effects, auto-tracks, re-runs on dependency change
4. **Immutable updates** for objects/arrays — always return new references from `update()`
5. Each primitive has a clear role: state → signal, derived → computed, side effect → effect
6. Computed is smart about dependencies — only re-runs when its specific tracked signals change
7. Template reads like `{{ signal() }}` — call the signal as a function
8. New `@for` control flow uses `track` for identity (like `trackBy` but built-in)
