# Lesson 1.5: Dependency Graph & Affected Commands

## Theory: Why This Matters

The dependency graph and affected commands are the core reasons teams adopt NX. They're what make monorepos **scale** — without them, CI times grow linearly with the number of projects, making monorepos impractical.

---

## How NX Builds the Dependency Graph

NX analyzes your codebase to understand project relationships through:

1. **TypeScript imports** — if `shell` imports from `@nx-mf-training/shared-ui`, NX records that dependency
2. **`dependsOn` in project.json** — explicit target-level dependencies (e.g., `"^build"` = build upstream first)
3. **`implicitDependencies` in project.json** — manually declared dependencies when imports aren't used (e.g., app depends on a config-only project)

### Visualize the Graph

```bash
npx nx graph                    # Interactive browser graph
npx nx graph --affected         # Only show affected subgraph
```

---

## `run-many` vs `affected`

| Command | What it does | When to use |
|---------|-------------|-------------|
| `nx run-many -t test` | Runs on **ALL** projects | Full CI validation, releases |
| `nx affected -t test` | Runs **only on affected** projects | PR checks, dev workflow |

### How `affected` Determines What Changed

```
Current branch
    ↕ compared against
defaultBase ("main" in nx.json)
    ↓
Changed files detected
    ↓
Files mapped to projects
    ↓
Dependency graph walked to find all downstream projects
    ↓
Only those projects run the target
```

### Commands

```bash
# Affected targets
npx nx affected -t test              # Only test affected projects
npx nx affected -t lint              # Only lint affected projects
npx nx affected -t build             # Only build affected projects
npx nx affected -t test,lint,build   # Multiple targets

# Affected info
npx nx show projects --affected      # List affected project names
npx nx affected --graph              # Visualize affected subgraph

# Compare against a different base
npx nx affected -t test --base=main --head=HEAD
```

---

## Real-World CI Impact

For a monorepo with 40 projects:

```yaml
# Without affected — tests everything
- run: npx nx run-many -t test,lint,build    # 120 tasks

# With affected — tests only what changed
- run: npx nx affected -t test,lint,build    # ~15 tasks (8x reduction)
```

Combined with NX caching, CI times can drop from 30 minutes to under 3 minutes.

---

## Parallel Execution

NX runs independent tasks in parallel by default:

```bash
npx nx affected -t test --parallel=5      # Run 5 tasks at once
npx nx run-many -t test --parallel=3      # Limit to 3 parallel
npx nx run-many -t test --parallel=false  # Sequential (for debugging)
```

NX uses the dependency graph to determine which tasks can run in parallel (no shared dependencies) vs. which must run sequentially (upstream must finish first).

---

## Implicit Dependencies

For projects that don't have TypeScript imports but still depend on each other:

```json
// project.json
{
  "implicitDependencies": ["config-lib"]
}
```

Use cases:
- An app depends on an infrastructure/config project
- A deploy project depends on a build project
- E2E tests depend on the app they test (NX infers this automatically)

---

## Key Takeaways

1. **Dependency graph** = NX's understanding of how projects relate (built from imports + config)
2. **`affected`** only runs tasks on projects impacted by your changes — the #1 CI optimization
3. **`run-many`** runs on all projects — use for full validation and releases
4. **`defaultBase`** in nx.json sets the git branch for comparison (must match your main branch)
5. **Parallel execution** is automatic — NX uses the graph to run independent tasks concurrently
6. **Affected + caching** together can reduce CI from 30 min to < 3 min at scale
7. Use `nx graph` and `nx affected --graph` to visualize and debug relationships
8. `implicitDependencies` handles relationships that aren't expressed through imports
