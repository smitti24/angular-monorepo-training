# Lesson 2.1: Signals vs Observables — When to Use What

## What Signals Are

Signals are **synchronous reactive primitives** that hold a value and notify consumers when it changes.

```typescript
const count = signal(0);       // Create with initial value
count();                        // Read: returns 0
count.set(1);                   // Write: set to 1
count.update(v => v + 1);      // Write: derive from current value
```

Key property: **signals always have a current value, and reading is synchronous.**

---

## Signals vs Observables Comparison

| | Observables | Signals |
|---|---|---|
| **Model** | Push-based stream of events over time | Pull-based reactive value |
| **Has current value?** | Only BehaviorSubject | Always |
| **Reading** | Subscribe (async) | Call the function (sync) |
| **Timing** | Values arrive over time | Value is always available now |
| **Teardown** | Must unsubscribe | Automatic (tied to component lifecycle) |
| **Change detection** | Triggers zone.js / markForCheck | Fine-grained — only re-renders what changed |
| **Good for** | Events, HTTP, WebSockets, complex async flows | UI state, component state, derived values |

---

## Why Angular Introduced Signals

**Change detection.** Zone.js patches every async API to know when something *might* have changed, then checks the entire component tree. Problems:
- Expensive (checks components that didn't change)
- Fragile (OnPush is opt-in and easy to get wrong)
- Magic (hard to debug)

Signals give Angular **fine-grained reactivity** — it knows exactly which binding changed, and only updates that. No zone.js needed.

---

## Decision Framework

### Use Signals When:
- Component/UI state (counters, toggles, form values)
- Derived/computed values
- State that templates read
- Replacing `BehaviorSubject` used purely for current state
- Anything where you'd use a simple class property today

### Use Observables When:
- HTTP requests (`HttpClient` returns Observables)
- WebSocket streams
- Complex async coordination (debounce, switchMap, retry, race conditions)
- Event streams where every emission matters
- Router events, form valueChanges

### The Practical Rule
```
BehaviorSubject + getValue() + next()  →  Replace with signal
pipe() + switchMap/debounceTime/etc    →  Keep as Observable
```

### One-Liner for Your Team
> **"Use signals for state, Observables for streams."**

---

## Interop: Bridging the Two Worlds

```typescript
import { toSignal, toObservable } from '@angular/core/rxjs-interop';

// Observable → Signal (for reading in templates)
const data = toSignal(this.http.get('/api/data'), { initialValue: [] });

// Signal → Observable (for piping through operators)
const count$ = toObservable(this.count);
```

`toSignal` is what you'll use most — consume Observable APIs in signal-based components without manual subscribe/unsubscribe.

---

## Angular's Signal Roadmap

### Already Signal-Based
- `signal()`, `computed()`, `effect()` (Angular 16+)
- `input()`, `output()`, `model()` — signal component APIs (Angular 17+)
- `viewChild()`, `contentChild()` as signals (Angular 17+)
- Zoneless change detection (experimental Angular 18, stable Angular 19+)

### Stays Observable-Based
- `HttpClient` (no plans to change)
- `Router` events
- `FormControl.valueChanges` / `statusChanges`
- Anything fundamentally a stream

---

## Key Takeaways

1. **Signals = synchronous reactive values** — always have a current value, read by calling
2. **Observables = async event streams** — values arrive over time, require subscribe
3. **Signals solve change detection** — fine-grained reactivity replaces zone.js tree checking
4. **Decision rule**: state → signals, streams → Observables
5. **`toSignal()`** bridges Observable APIs into signal-based components
6. **`toObservable()`** bridges signals into RxJS pipelines when you need operators
7. Angular is moving toward signals, but Observables aren't going away for genuinely async workflows
8. Replace `BehaviorSubject` patterns with signals — they're cleaner for the same use case
