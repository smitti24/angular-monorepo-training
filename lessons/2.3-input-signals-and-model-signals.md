# Lesson 2.3: Input Signals & Model Signals

## The New Signal-Based Component APIs

| Old | New | What it does |
|-----|-----|-------------|
| `@Input() task: Task` | `task = input<Task>()` | Read-only signal input |
| `@Input({ required: true })` | `task = input.required<Task>()` | Required signal input |
| `@Output() toggle = new EventEmitter()` | `toggle = output<number>()` | Event emitter (cleaner syntax, not a signal) |
| `[(ngModel)]` two-way binding | `filter = model<string>('all')` | Writable signal that syncs parent ↔ child |

---

## input() — Signal-Based Inputs

```typescript
// Optional with default
name = input<string>('default');

// Required (no default needed)
task = input.required<Task>();

// With transform
size = input(0, { transform: numberAttribute });

// With alias
task = input.required<Task>({ alias: 'taskData' });
```

### Key benefit: inputs are reactive signals
```typescript
task = input.required<Task>();

// Can use in computed — reacts to input changes automatically
fullTitle = computed(() => `Task: ${this.task().title}`);

// No more ngOnChanges or setter tricks!
```

---

## output() — Cleaner EventEmitter

```typescript
// Declaration
toggle = output<number>();

// Emit
this.toggle.emit(taskId);

// Template (same as @Output)
<app-task-item (toggle)="handleToggle($event)" />
```

Not a signal — just cleaner syntax for `EventEmitter`. Same pattern in templates.

---

## model() — Two-Way Binding Signal

```typescript
// Child component
filter = model<string>('all');           // optional with default
filter = model.required<string>();       // required

// Parent template — two-way binding
<app-task-filter [(filter)]="parentFilter" />
```

`model()` creates a **writable signal** that syncs both directions:
- Parent sets value → child signal updates
- Child calls `this.filter.set('active')` → parent signal updates

No manual event wiring needed.

### How two-way binding works under the hood
```html
<!-- This: -->
<app-task-filter [(filter)]="parentFilter" />

<!-- Is sugar for: -->
<app-task-filter [filter]="parentFilter()" (filterChange)="parentFilter.set($event)" />
```

---

## Exercise: Refactor Task Tracker

### 1. TaskItem Component (input + output)

**Generate:**
```bash
npx nx generate @nx/angular:component --name=task-item --path=apps/shell/src/app/task-tracker/task-item --inline-template=false --inline-style=false
```

**task-item.ts:**
```typescript
import { Component, input, output } from '@angular/core';
import { Task } from '../task';

@Component({
  selector: 'app-task-item',
  templateUrl: './task-item.html',
  styleUrl: './task-item.css',
})
export class TaskItem {
  task = input.required<Task>();
  toggled = output<number>();
  removed = output<number>();
}
```

**task-item.html:**
```html
<li>
  <input type="checkbox" [checked]="task().done" (change)="toggled.emit(task().id)" />
  <span [style.text-decoration]="task().done ? 'line-through' : 'none'">{{ task().title }}</span>
  <button (click)="removed.emit(task().id)">x</button>
</li>
```

### 2. TaskFilter Component (model + input)

**Generate:**
```bash
npx nx generate @nx/angular:component --name=task-filter --path=apps/shell/src/app/task-tracker/task-filter --inline-template=false --inline-style=false
```

**task-filter.ts:**
```typescript
import { Component, model, input } from '@angular/core';

@Component({
  selector: 'app-task-filter',
  templateUrl: './task-filter.html',
  styleUrl: './task-filter.css',
})
export class TaskFilter {
  filter = model.required<'all' | 'active' | 'completed'>();
  stats = input.required<{ total: number; done: number; remaining: number }>();
}
```

**task-filter.html:**
```html
@let s = stats();
<button (click)="filter.set('all')">All ({{ s.total }})</button>
<button (click)="filter.set('active')">Active ({{ s.remaining }})</button>
<button (click)="filter.set('completed')">Done ({{ s.done }})</button>
```

### 3. Updated TaskTracker (parent)

**task-tracker.ts imports:**
```typescript
imports: [TaskItem, TaskFilter],
```

**task-tracker.html:**
```html
<h2>Task Tracker</h2>

<div>
  <input #newTask placeholder="New task..." />
  <button (click)="addTask(newTask.value); newTask.value = ''">Add</button>
</div>

<app-task-filter [(filter)]="filter" [stats]="stats()" />

<ul>
  @for (task of filteredTasks(); track task.id) {
    <app-task-item [task]="task" (toggled)="toggleTask($event)" (removed)="removeTask($event)" />
  } @empty {
    <li>No tasks found</li>
  }
</ul>
```

---

## Key Takeaways

1. **`input()`** replaces `@Input()` — inputs are now signals, reactive in computed/effect
2. **`input.required()`** — no `!` assertion needed, Angular enforces at compile time
3. **`output()`** replaces `@Output()` — cleaner syntax, same template behavior
4. **`model()`** = two-way binding signal — parent and child stay in sync automatically
5. **`[(prop)]="signal"`** is the two-way binding syntax for model signals
6. Input signals eliminate the need for `ngOnChanges` — use `computed()` instead
7. Prefer `input.required()` over optional inputs when the parent must provide the value
8. `output()` is NOT a signal — it's just a cleaner EventEmitter API
