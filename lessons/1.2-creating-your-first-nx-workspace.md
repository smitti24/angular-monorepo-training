# Lesson 1.2: Creating Your First NX Workspace

## Theory

### NX Plugin Architecture

NX is plugin-based. The core package (`nx`) handles:
- Task runner and orchestration
- Computation caching
- Dependency graph

Plugins add framework-specific capabilities:
- **`@nx/angular`** — Angular generators (app, lib, component) and executors (build, serve, test)
- **`@nx/react`**, **`@nx/node`**, etc. — same pattern for other frameworks

Install a plugin to unlock its generators:
```bash
npm install -D @nx/angular
```

### Workspace Layout Convention

NX workspaces follow a standard layout:

```
my-workspace/           ← Root = git repo + NX workspace
├── apps/               ← Deployable applications
├── libs/               ← Shared libraries
├── nx.json             ← Workspace-level config
├── package.json
└── tsconfig.base.json  ← Shared TS config
```

**The NX workspace must live at the root of the git repo.** This is the industry standard because:
- NX Console (VS Code extension) expects `nx.json` at root
- CI/CD pipelines don't need extra `cd` commands
- NX Cloud and caching work out of the box
- `create-nx-workspace` generates at root by default

### project.json vs angular.json

In a standard Angular CLI project, everything lives in one `angular.json`. In NX, each project gets its own `project.json`. This is better for monorepos because:
- Changes to one project's config don't affect others
- Less merge conflicts in teams
- Easier to reason about per-project settings

### Generators

Generators scaffold code. They're the NX equivalent of `ng generate` but more powerful:

```bash
npx nx generate @nx/angular:application --name=shell
```

Generator options can be saved as defaults in `nx.json`:
```json
{
  "generators": {
    "@nx/angular:application": {
      "e2eTestRunner": "playwright",
      "unitTestRunner": "vitest-angular",
      "style": "css"
    }
  }
}
```

---

## Hands-On: Generate the Shell App

### Step 1: Install the Angular Plugin

```bash
npm install -D @nx/angular
```

### Step 2: Generate the Application

```bash
npx nx generate @nx/angular:application \
  --name=shell \
  --directory=apps/shell \
  --style=css \
  --routing=true \
  --standalone=true \
  --prefix=app \
  --ssr=false
```

| Flag | Value | Why |
|------|-------|-----|
| `--name` | `shell` | Will become the MF host app later |
| `--directory` | `apps/shell` | NX convention: apps in `apps/` |
| `--standalone` | `true` | Modern Angular — no NgModules |
| `--routing` | `true` | Needed for MF navigation |
| `--style` | `css` | Swapped to Tailwind in Module 4 |
| `--ssr` | `false` | MFs don't play well with SSR |
| `--prefix` | `app` | Component selector prefix |

> **Why "shell"?** In microfrontend architecture, the **shell** (or host) is the container app that loads remote micro-apps. Naming it now saves a rename later.

Interactive prompts will ask for:
- **Unit test runner** → `angular-vitest` (faster than Jest, native ESM)
- **E2E test runner** → `playwright` (more reliable than Cypress, better CI)
- **Bundler** → `esbuild` (much faster builds than webpack)

> **Note:** Module Federation requires webpack. We'll switch when we get to Module 7. This is a normal workflow — esbuild for dev speed now, webpack when MF is needed.

### Step 3: Serve the App

```bash
npx nx serve shell
```

Opens on `http://localhost:4200`.

---

## Key Files Walkthrough

### project.json — NX Project Config

```json
{
  "name": "shell",
  "projectType": "application",
  "prefix": "app",
  "sourceRoot": "apps/shell/src",
  "tags": [],
  "targets": {
    "build": {
      "executor": "@angular/build:application",
      "outputs": ["{options.outputPath}"],
      "options": { "outputPath": "dist/apps/shell", ... },
      "configurations": {
        "production": { "budgets": [...], "outputHashing": "all" },
        "development": { "optimization": false, "sourceMap": true }
      },
      "defaultConfiguration": "production"
    },
    "serve": {
      "executor": "@angular/build:dev-server",
      "defaultConfiguration": "development"
    },
    "test": { "executor": "@angular/build:unit-test" },
    "lint": { "executor": "@nx/eslint:lint" }
  }
}
```

Key concepts:
- **Targets** = commands NX can run (`build`, `serve`, `test`, `lint`)
- **Executors** = the tools that run them (e.g., `@angular/build:application`)
- **Configurations** = per-environment settings (`production` vs `development`)
- **`defaultConfiguration`** = which config runs by default (serve defaults to dev, build defaults to prod)
- **`tags: []`** = used for enforcing library import boundaries (Module 3)
- **`outputs`** = tells NX where artifacts go, enabling caching

### app.config.ts — Standalone Application Config

```typescript
export const appConfig: ApplicationConfig = {
  providers: [
    provideBrowserGlobalErrorListeners(),
    provideRouter(appRoutes)
  ],
};
```

No NgModule. Providers are registered here. Future additions like `provideHttpClient()` or state management go here.

### main.ts — Bootstrap

```typescript
bootstrapApplication(App, appConfig).catch((err) => console.error(err));
```

Bootstraps a standalone component directly — no `AppModule.bootstrap`.

### app.ts — Root Component

```typescript
@Component({
  imports: [NxWelcome, RouterModule],
  selector: 'app-root',
  templateUrl: './app.html',
  styleUrl: './app.css',
})
export class App {
  protected title = 'shell';
}
```

Standalone component with `imports` in the decorator. `RouterModule` is imported at the component level, not in a module.

### app.routes.ts — Route Config

```typescript
export const appRoutes: Route[] = [];
```

Empty for now. In MF setup, remote app routes will be lazy-loaded here.

### nx.json — Workspace Config

```json
{
  "targetDefaults": {
    "@angular/build:application": {
      "cache": true,
      "dependsOn": ["^build"],
      "inputs": ["production", "^production"]
    }
  },
  "plugins": [
    { "plugin": "@nx/playwright/plugin", "options": { "targetName": "e2e" } },
    { "plugin": "@nx/eslint/plugin", "options": { "targetName": "lint" } }
  ],
  "generators": {
    "@nx/angular:application": {
      "e2eTestRunner": "playwright",
      "linter": "eslint",
      "style": "css",
      "unitTestRunner": "vitest-angular"
    }
  }
}
```

- **`targetDefaults`** — global settings for all projects using that executor
- **`cache: true`** — enables NX computation caching for that target
- **`dependsOn: ["^build"]`** — build dependencies first (topological ordering)
- **`plugins`** — Playwright and ESLint registered as NX plugins (auto-detect targets)
- **`generators`** — saved defaults so future `nx generate` reuses your choices

---

## Generated Project Structure

```
angular-monorepo-training/
├── apps/
│   ├── shell/                      ← Angular 21 standalone app
│   │   ├── src/
│   │   │   ├── app/
│   │   │   │   ├── app.ts          ← Root component (standalone)
│   │   │   │   ├── app.config.ts   ← App providers
│   │   │   │   ├── app.routes.ts   ← Route definitions
│   │   │   │   ├── app.html / app.css
│   │   │   │   ├── app.spec.ts     ← Unit test (Vitest)
│   │   │   │   └── nx-welcome.ts   ← NX placeholder
│   │   │   ├── main.ts             ← Bootstrap
│   │   │   ├── styles.css          ← Global styles
│   │   │   └── index.html
│   │   ├── public/favicon.ico
│   │   ├── project.json            ← NX project config
│   │   └── tsconfig.*.json
│   └── shell-e2e/                  ← Playwright E2E
│       ├── src/example.spec.ts
│       └── playwright.config.ts
├── nx.json
├── package.json
└── tsconfig.base.json
```

---

## Key Takeaways

1. NX is **plugin-based** — install `@nx/angular` to unlock Angular generators and executors
2. Each project gets its own **`project.json`** (not one big `angular.json`)
3. **Targets** are commands, **executors** are the tools that run them
4. **NX caching** is opt-in per target and dramatically speeds up builds/tests
5. Generator choices are **saved as defaults** in `nx.json` for consistency
6. Modern Angular uses **standalone components** — no NgModules needed
7. Name your host app **"shell"** from day one to align with MF conventions
