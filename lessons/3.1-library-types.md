# Lesson 3.1: Library Types (Feature, UI, Data-Access, Util)

## Theory

### Why Libraries?

Right now you have one app — `shell`. Everything lives inside it. That works fine for a single app, but you're building a **monorepo** that will have multiple microfrontend apps. The question becomes: where does shared code live?

NX's answer: **libraries**.

Libraries are the primary unit of code organisation in an NX workspace. Apps should be thin shells — they compose libraries. Think of apps as **deployment units** and libraries as **development units**.

### The 4 Library Types

NX doesn't enforce these categories technically — they're an **architectural convention** adopted by the NX community. But they're powerful because they give every piece of code a clear home, and later we'll enforce boundaries between them with tags (Lesson 3.3).

#### 1. Feature Libraries (`feature-*`)
- **What:** Smart components, pages, routes, container components
- **Contains:** Components that orchestrate business logic, inject services, manage state
- **Depends on:** data-access, ui, util
- **Example:** `feature-dashboard`, `feature-user-profile`, `feature-checkout`
- **Rule:** Features are app-specific or shared. They wire everything together.

#### 2. UI Libraries (`ui` / `ui-*`)
- **What:** Presentational (dumb) components, pipes, directives
- **Contains:** Components that receive data via inputs and emit via outputs — no service injection
- **Depends on:** util only
- **Example:** `ui-buttons`, `ui-card`, `ui-table`, `ui-form-fields`
- **Rule:** Zero business logic. Reusable across features and apps. Think "design system".

#### 3. Data-Access Libraries (`data-access-*`)
- **What:** Services, API clients, state management (stores), interceptors, guards
- **Contains:** Everything that talks to backends or manages application state
- **Depends on:** util only
- **Example:** `data-access-users`, `data-access-auth`, `data-access-products`
- **Rule:** No components. Pure logic and state.

#### 4. Util Libraries (`util-*`)
- **What:** Pure functions, constants, types/interfaces, validators, helpers
- **Contains:** Code with zero Angular dependencies (ideally). No services, no components.
- **Depends on:** nothing (or other utils)
- **Example:** `util-formatting`, `util-validators`, `util-types`
- **Rule:** The foundation layer. Everything can depend on utils, utils depend on nothing.

### The Dependency Rule (Critical)

```
feature → data-access → util
feature → ui → util
feature → util

NEVER: ui → data-access (UI must stay dumb)
NEVER: util → anything above it
NEVER: data-access → feature (no circular deps)
```

This forms a **layered architecture**. Data flows down through injection, events flow up through outputs.

### Library Grouping & Naming Convention

Libraries are organised under `libs/` with **grouping folders**:

```
libs/
├── shared/              ← Used across multiple apps
│   ├── ui/              ← Shared presentational components
│   ├── data-access/     ← Shared services/stores
│   └── util/            ← Shared utilities
├── dashboard/           ← Feature domain
│   ├── feature/         ← Dashboard feature (smart components)
│   ├── ui/              ← Dashboard-specific UI components
│   └── data-access/     ← Dashboard API/state
└── users/               ← Feature domain
    ├── feature/         ← Users feature
    └── data-access/     ← Users API/state
```

This is called **domain-driven organisation**. Each domain groups its own feature, UI, data-access, and util libraries.

### Real-World Impact (Tech Lead Perspective)

As a Tech Lead, this structure gives you:
1. **Clear code ownership** — teams own domains, not random folders
2. **Enforced architecture** — NX tags prevent UI libs importing services (Lesson 3.3)
3. **Parallel development** — teams work in separate libraries with minimal conflicts
4. **Incremental builds** — NX only rebuilds/retests changed libraries
5. **Microfrontend readiness** — features map cleanly to remote apps later

---

## Hands-On: Create Your First Libraries

We'll create a small set of libraries for a "tasks" domain (building on your Module 2 task tracker) plus shared utilities.

### Step 1: Generate a shared UI library

```bash
npx nx generate @nx/angular:library --name=ui --directory=libs/shared/ui --standalone --prefix=ui --skipModule
```

When prompted:
- Bundler: choose `none` (not buildable yet — Lesson 3.4)
- Pick the defaults for other options

### Step 2: Generate a shared util library

```bash
npx nx generate @nx/angular:library --name=util --directory=libs/shared/util --standalone --prefix=lib --skipModule
```

### Step 3: Generate a tasks data-access library

```bash
npx nx generate @nx/angular:library --name=data-access --directory=libs/tasks/data-access --standalone --prefix=lib --skipModule
```

### Step 4: Generate a tasks feature library

```bash
npx nx generate @nx/angular:library --name=feature --directory=libs/tasks/feature --standalone --prefix=lib --skipModule
```

### Step 5: Explore What Was Generated

After generating, run:

```bash
npx nx show projects
```

You should see your new libraries alongside `shell` and `shell-e2e`.

Then run:

```bash
npx nx graph
```

Open the graph in your browser. You won't see any connections yet (no imports between libraries), but you'll see all projects listed.

### Step 6: Examine the Generated Files

Look at the structure of one library (e.g., `libs/shared/ui/`):
- `project.json` — NX project config
- `src/index.ts` — public API barrel file (this is what consumers import)
- `src/lib/` — where your actual code goes

Check `tsconfig.base.json` at the workspace root — NX auto-added path mappings so you can import like:
```typescript
import { something } from '@nx-mf-training/shared-ui';
```

---

## Key Takeaways

1. **4 library types:** Feature (smart), UI (dumb), Data-Access (services/state), Util (pure functions)
2. **Dependency rule:** Feature → Data-Access/UI → Util. Never go backwards.
3. **Apps are thin** — they compose features. Libraries are where code lives.
4. **Domain grouping** — organise by business domain, not technical layer
5. **`src/index.ts`** is the public API — only export what consumers need
6. **Path mappings** in `tsconfig.base.json` enable clean imports like `@workspace/shared-ui`

---

## What's Next

In **Lesson 3.2**, you'll move your task tracker code from `shell` into these libraries — services into data-access, components into feature/UI — and see the dependency graph light up.
